  /* Set all primitive dets fields to 0 */
  memset(Pr, 0, sizeof(an5PRIM));
  /* Calculate memory size for primitives */
  size = sizeof(an5VERTEX) * NoofV + sizeof(INT) * NoofI;
  /* Allocate memory */
  if ((Pr->V = malloc(size)) == NULL)
    return FALSE;
  /* Fill allocated memory by 0 */
  memset(Pr->V, 0, size);
  /* Set index array pointer */
  Pr->I = (INT *)(Pr->V + NoofV);
  /* Store data sizes */
  Pr->NumOfV = NoofV;
  Pr->NumOfElements = NoofI;
   
#pragma comment(lib, "opengl32")
#pragma comment(lib, "glu32")


  case WM_ACTIVATE:
    if (LOWORD(wParam) == WA_INACTIVE)
    {
      AN5_Anim.IsActive = FALSE;
      AN5_Anim.IsInput = FALSE;
    }
    else
    {
      AN5_Anim.IsActive = TRUE;
      AN5_Anim.IsInput = TRUE;
    }
    return 0;
  case WM_ENTERSIZEMOVE:
    AN5_Anim.IsInput = FALSE;
    return 0;
  case WM_EXITSIZEMOVE:
    AN5_Anim.IsInput = FALSE;
    return 0;



/*  old camera */
  AN5_RndMatrView = MatrView(Loc, At, Up1);
  AN5_RndMatrVP = MatrMulMatr(AN5_RndMatrView, AN5_RndMatrProj);



    IsActive,                    /* Window active flag */
    IsInput;                     /* Input handle flag */

/* Draw primitive function.
 * ARGUMENTS:
 *   - pointer to primitive to free:
 *       vg4PRIM *Pr;
 *   - transformation 'world' matrix:
 *       MATR World;
 * RETURNS: None.
 */
VOID AN5_RndPrimDraw( an5PRIM *Pr, MATR World )
{
  MATR
    w = MatrMulMatr(Pr->Trans, World),
    wnormal = MatrTranspose(MatrInverse(w)),
    wvp = MatrMulMatr(w, AN5_RndMatrVP);
  INT
    ProgId = AN5_RndShdProgId,
    loc,
    gl_prim_type = Pr->Type == AN5_RND_PRIM_LINES ? GL_LINES :
                   Pr->Type == AN5_RND_PRIM_TRIMESH ? GL_TRIANGLES :
                   Pr->Type == AN5_RND_PRIM_TRISTRIP ? GL_TRIANGLE_STRIP :
                   Pr->Type == AN5_RND_PRIM_LINESTRIP ? GL_LINE_STRIP :
                   GL_POINTS;
 
  glUseProgram(ProgId);
  if ((loc = glGetUniformLocation(ProgId, "MatrWVP")) != -1)
    glUniformMatrix4fv(loc, 1, FALSE, wvp.A[0]);
  if ((loc = glGetUniformLocation(ProgId, "MatrWInv")) != -1)
    glUniformMatrix4fv(loc, 1, FALSE, wnormal.A[0]);
  if ((loc = glGetUniformLocation(ProgId, "MatrW")) != -1)
    glUniformMatrix4fv(loc, 1, FALSE, w.A[0]);
  if ((loc = glGetUniformLocation(ProgId, "Time")) != -1)
    glUniform1f(loc, AN5_Anim.Time);
  if ((loc = glGetUniformLocation(ProgId, "CamLoc")) != -1)
    glUniform3fv(loc, 1, &AN5_RndCamLoc.X);
  if ((loc = glGetUniformLocation(ProgId, "CamRight")) != -1)
    glUniform3fv(loc, 1, &AN5_RndCamRight.X);
  if ((loc = glGetUniformLocation(ProgId, "CamUp")) != -1)
    glUniform3fv(loc, 1, &AN5_RndCamUp.X);
  if ((loc = glGetUniformLocation(ProgId, "CamDir")) != -1)
    glUniform3fv(loc, 1, &AN5_RndCamDir.X);
 
  glBindVertexArray(Pr->VA);
  if (Pr->IBuf == 0)
    glDrawArrays(gl_prim_type, 0, Pr->NumOfElements);
  else
  {
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, Pr->IBuf);
    glDrawElements(gl_prim_type, Pr->NumOfElements, GL_UNSIGNED_INT, NULL);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
  }
  glBindVertexArray(0);
  glUseProgram(0);
} /* End of 'AN5_RndPrimDraw' function */


/* Shader stock */
#define AN5_MAX_SHADERS 30
an5SHADER AN5_RndShaders[AN5_MAX_SHADERS]; /* Array of shaders */
INT AN5_RndShadersSize;                    /* Shaders array store */





/* Shader program load function.
 * ARGUMENTS:
 *   - shader directory files prefix (base from 'bin/shaders/'):
 *       CHAR *FileNamePrefix;
 * RETURNS:
 *   (INT) OpenGL shader program index (0 if error is occured).
 */
INT AN5_RndShdLoad( CHAR *FileNamePrefix )
{
  INT prg = 0;
  CHAR *txt;
  BOOL isok = TRUE;
  struct
  {
    CHAR *Name; /* Shader name */
    INT Type;   /* Shader OpenGL type (see GL_***_SHADER) */
    INT Id;     /* Result shader OpenGL Id */
  } shds[] =
  {
    {"vert", GL_VERTEX_SHADER},
    {"frag", GL_FRAGMENT_SHADER},
  };
  INT i, res, NoofS = sizeof(shds) / sizeof(shds[0]);
  static CHAR Buf[30000];

  for (i = 0; i < NoofS; i++)
  {
    /* Load file */
    sprintf(Buf, "bin/shaders/%s/%s.glsl", FileNamePrefix, shds[i].Name);
    txt = AN5_RndShdLoadTextFromFile(Buf);
    if (txt == NULL)
    {
      AN5_RndShdLog(FileNamePrefix, shds[i].Name, "Error load file");
      isok = FALSE;
      break;
    }
    /* Create shader */
    if ((shds[i].Id = glCreateShader(shds[i].Type)) == 0)
    {
      AN5_RndShdLog(FileNamePrefix, shds[i].Name, "Error shader creation");
      free(txt);
      isok = FALSE;
      break;
    }
    /* Send text to shader for compile */
    glShaderSource(shds[i].Id, 1, &txt, NULL);
    free(txt);

    /* Compile shader */
    glCompileShader(shds[i].Id);
    glGetShaderiv(shds[i].Id, GL_COMPILE_STATUS, &res);
    if (res != 1)
    {
      glGetShaderInfoLog(shds[i].Id, sizeof(Buf), &res, Buf);
      AN5_RndShdLog(FileNamePrefix, shds[i].Name, Buf);
      isok = FALSE;
      break;
    }
  }

  /* Create program */
  if (isok)
  {
    if ((prg = glCreateProgram()) == 0)
    {
      AN5_RndShdLog(FileNamePrefix, "PROG", "Error program creation");
      isok = FALSE;
    }
    else
    {
      /* Attach shaders to program */
      for (i = 0; i < NoofS; i++)
        if (shds[i].Id != 0)
          glAttachShader(prg, shds[i].Id);

      /* Link program */
      glLinkProgram(prg);
      glGetProgramiv(prg, GL_LINK_STATUS, &res);
      if (res != 1)
      {
        glGetProgramInfoLog(prg, sizeof(Buf), &res, Buf);
        AN5_RndShdLog(FileNamePrefix, "PROG", Buf);
        isok = FALSE;
      }
    }
  }
  if (!isok)
  {
    /* Handle errors */
    /* Delete shaders */
    for (i = 0; i < NoofS; i++)
      if (shds[i].Id != 0)
      {
        if (prg != 0)
          glDetachShader(prg, shds[i].Id);
        glDeleteShader(shds[i].Id);
      }
    /* Delete program */
    if (prg != 0)
      glDeleteProgram(prg);
    prg = 0;
  }

  return prg;
} /* END OF 'AN5_RndShdLoad' function */



/* Create primiteve function
 * ARGUMENTS:
 *   - Pointer on primiteve:
 *      an5PRIM *Pr;
 *   - Primitive type:
 *      an5PRIM_TYPE Type;
 *   - Vertex array:
 *      an5VERTEX *V;
 *   - Vertex array size:
 *      INT NoofV;
 *   - Index array:
 *      INT *I;
 *   - Index array size:
 *      INT NoofI;
 * RETURNS:
 *   - (BOOL) True if success, False otherwise.
 */
BOOL AN5_RndPrimCreate( an5PRIM *Pr, an5PRIM_TYPE Type, an5VERTEX *V, INT NoofV, INT *I, INT NoofI )   

  case WM_ACTIVATE:
    if (LOWORD(wParam) == WA_INACTIVE)
    {
      AN5_Anim.IsActive = FALSE;
      AN5_Anim.IsInput = FALSE;
    }
    else
    {
      AN5_Anim.IsActive = TRUE;
      AN5_Anim.IsInput = TRUE;
    }
    return 0;
  case WM_ENTERSIZEMOVE:
    AN5_Anim.IsInput = FALSE;
    return 0;
  case WM_EXITSIZEMOVE:
    AN5_Anim.IsInput = FALSE;
    return 0;



/*  old camera */
  AN5_RndMatrView = MatrView(Loc, At, Up1);
  AN5_RndMatrVP = MatrMulMatr(AN5_RndMatrView, AN5_RndMatrProj);



    IsActive,                    /* Window active flag */
    IsInput;                     /* Input handle flag */

void main( void )
{
  gl_Position = MatrWVP * vec4(InPosition, 1);
  vs_out.Color = InColor.rgb;
  vs_out.Normal = mat3(MatrInv) * InNormal;
}




  INT mips;

  if (AN5_RndTexturesSize >= AN5_MAX_TEXTURES)
    return -1;
  /* Setup OpenGl texture */
  glGenTextures(1, &AN5_RndTextures[AN5_RndTexturesSize].TexId);
  glBindTexture(GL_TEXTURE_2D, AN5_RndTextures[AN5_RndTexturesSize].TexId);
  mips = log(W > H ? W : H) / log(2);
  mips = mips < 1 ? 1 : mips;

  glTexStorage2D(glTexStorage2D(GL_TEXTURE_2D, mips,
    C == 4 ? GL_BGRA : C == 3 GL_BGR : GL_R8, W, H);

  if (Bits != NULL)
    glTexStorage2D(GL_TEXTURE_2D, 0, 0, 0, W, H,
    C == 4 ? GL_BGRA : C == 3 GL_BGR : GL_LUMINANCE, GL_UNSIGNALED_BYTE, Bits);

  glGenerateMipmap(GL_TEXTURE_2D);

  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINER

                                                              
  if ((F = fopen(Name, "rb")) != NULL)
  {
    INT mips;
    BYTE *mem;

    fread(&w, 2, 1, F);
    fread(&h, 2, 1, F);

    if ((mem = malloc(w * h * 3)) != NULL)
    {
    fread(mem, 3, w * h, F);

    glBindTexture(GL_TEXTURE_2D, Uni->TexId);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    mips = log(w > h ? w : h) / log(2);
    mips = mips < 1 ? 1 : mips;

    glTexStorage2D(GL_TEXTURE_2D, mips, GL_RGB8, w, h);
    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, w, h,
                    GL_BGR, GL_UNSIGNED_BYTE, mem);

    glGenerateMipmap(GL_TEXTURE_2D);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

    free(mem);
    }
    fclose(F);
  }

/*
  if ((loc = glGetUniformLocation(ProgId, "Time")) != -1)
    glUniform1f(loc, AN5_Anim.Time);
  if ((loc = glGetUniformLocation(ProgId, "MatrWVP")) != -1)
    glUniformMatrix4fv(loc, 1, FALSE, wvp.A[0]);
  if ((loc = glGetUniformLocation(ProgId, "MatrInv")) != -1)
    glUniformMatrix4fv(loc, 1, FALSE, wnormal.A[0]);
  if ((loc = glGetUniformLocation(ProgId, "MatrW")) != -1)
    glUniformMatrix4fv(loc, 1, FALSE, w.A[0]);
  if ((loc = glGetUniformLocation(ProgId, "CamLoc")) != -1)
    glUniform3fv(loc, 1, &AN5_RndCamLoc.X);
  if ((loc = glGetUniformLocation(ProgId, "CamRight")) != -1)
    glUniform3fv(loc, 1, &AN5_RndCamRight.X);
  if ((loc = glGetUniformLocation(ProgId, "CamUp")) != -1)
    glUniform3fv(loc, 1, &AN5_RndCamUp.X);
  if ((loc = glGetUniformLocation(ProgId, "CamDir")) != -1)
    glUniform3fv(loc, 1, &AN5_RndCamDir.X);
*/


+ vec3(sin(Time * 5), 0, 0) 

  for (m = 0; m < NumOfMaterials; m++)
  {
    struct
    {
      CHAR Name[300]; /* Material name */
      /* Illumination coefficients */
      VEC Ka, Kd, Ks;     /* Ambient, diffuse, specular coefficients */
      FLT Ph;             /* Phong power coefficient – shininess */
      FLT Trans;          /* Transparency factor */
      DWORD Tex[8];       /* Texture references 
                           * (8 time: texture number in G3DM file, -1 if no texture) */
      /* Shader information */
      CHAR ShaderString[300]; /* Additional shader information */
      DWORD Shader;       /* Shader number (uses after load into memory) */
    } *fmat;
    an5MATERIAL mtl;

    fmat = (VOID *)ptr;
    ptr += sizeof(*fmat);
    strncpy(mtl.Name, fmat->Name, AN5_STR_MAX);
    mtl.Ka = fmat->Ka;
    mtl.Kd = fmat->Kd;
    mtl.Ks = fmat->Ks;
    mtl.Ph = fmat->Ph;
    mtl.Trans = fmat->Trans;
    for (t = 0; t < 8; t++)
      mtl.Tex[t] = fmat->Tex[t] == -1 ? -1 : AN5_RndTexturesSize + fmat->Tex[t];
    AN5_RndMtlAdd(&mtl);
  }
  /* Load textures */
  for (t = 0; t < NumOfTextures; t++)
  {
    CHAR *Name;
    DWORD W, H, C;

    Name = (CHAR *)ptr;
    ptr += 300;
    W = *(DWORD *)ptr;
    ptr += 4;
    H = *(DWORD *)ptr;
    ptr += 4;
    C = *(DWORD *)ptr;
    ptr += 4;
    AN5_RndTexAddImg(Name, W, H, C, ptr);
    ptr += W * H * C;
  }
  for (c = -i; c <= i ; c++)
    for (o = -i; o <= i; o++)
      for (w = -i; w <= i; w++)
      {
        AN5_RndPrimDraw(&Uni->Pr,
          MatrMulMatr3(MatrRotateX(20 * cos(AN5_Anim.Time + c + o * 3 * (i + w * i))),
                             MatrRotateY(0 * AN5_Anim.Time),
                             MatrTranslate(VecDivNum(VecSet(w * 3, o * 3, c * 3), 1))));
      }




  
